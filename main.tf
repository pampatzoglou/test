variable "deployment_short_sha" {
  description = "Git short SHA of the deployment"
  type        = string
  default     = "init"
}

variable "deployment_az" {
  description = "Deployment Availability Zones"
  type        = list(string)
  default     = ["locA", "locB"]
}

variable "deployment_instances" {
  description = "Number of deployment instances"
  type        = number
  default     = 1
}

# Read the existing state file if it exists
data "local_file" "deployment_state" {
  count    = fileexists("deployment_state.json") ? 1 : 0
  filename = "deployment_state.json"
}

locals {
  deployment_az = var.deployment_az
  az_map = {
    for idx, az in local.deployment_az : az => local.deployment_az[(idx + 1) % length(local.deployment_az)]
  }
  deployment_short_sha = var.deployment_short_sha
  deployment_instances = var.deployment_instances

  # Determine previous SHA from state file or default to empty
  previous_sha = length(data.local_file.deployment_state) > 0 ? try(jsondecode(data.local_file.deployment_state[0].content).current_sha, "") : ""
}

resource "null_resource" "control_plane_backup" {
  triggers = {
    always_run = timestamp() # Forces the backup resource to run on every apply
  }

  provisioner "local-exec" {
    command = <<EOF
      date +'%Y-%m-%d %H:%M:%S.%N - Creating ETCD backup of previous deployment (SHA: ${local.previous_sha}) before updating to ${local.deployment_short_sha}' >> logs/deployment.log
      sleep 5
      date +'%Y-%m-%d %H:%M:%S.%N - Backup complete' >> logs/deployment.log
    EOF
  }
}

# Use the control_plane module for locA
module "control_plane_A" {
  source     = "./modules/control_plane"
  depends_on = [null_resource.control_plane_backup]

  az                   = local.deployment_az[0]
  next_az              = local.az_map[local.deployment_az[0]]
  deployment_short_sha = local.deployment_short_sha
  previous_sha         = local.previous_sha
  deployment_instances = local.deployment_instances
}

# Trigger for control_plane_B to only run if control_plane_A changed
resource "null_resource" "control_plane_B_trigger" {
  triggers = {
    control_plane_A_ids = join(",", module.control_plane_A.control_plane_ids)
  }
}

# Use the control_plane module for locB
module "control_plane_B" {
  source     = "./modules/control_plane"
  depends_on = [module.control_plane_A] # Ensures processing locA first and only if it changed

  az                   = local.deployment_az[1]
  next_az              = local.az_map[local.deployment_az[1]]
  deployment_short_sha = local.deployment_short_sha
  previous_sha         = local.previous_sha
  deployment_instances = local.deployment_instances
}

# Update deployment state file after successful deployment
resource "null_resource" "deployment_state" {
  # No dependencies to ensure this always runs regardless of other resources

  triggers = {
    always_run = timestamp() # Forces the resource to run on every apply
  }

  provisioner "local-exec" {
    command = <<EOF
      echo '{"deployment_az": ${jsonencode(local.deployment_az)}, "current_sha": "${local.deployment_short_sha}", "instance_count": ${local.deployment_instances}, "last_updated": "'$(date '+%Y-%m-%d %H:%M:%S.%N')'"}' > logs/deployment_state.json
      # date +'%Y-%m-%d %H:%M:%S.%N - Updated deployment state file with current SHA: ${local.deployment_short_sha} and AZ info: ${jsonencode(local.deployment_az)}' >> logs/deployment.log
    EOF
  }
}

# Output the control plane instance IDs
output "control_plane_ids" {
  description = "IDs of the control plane instances"
  value = {
    "${local.deployment_az[0]}" = module.control_plane_A.control_plane_ids
    "${local.deployment_az[1]}" = module.control_plane_B.control_plane_ids
  }
}

# module "provision" {
#   source = "./modules/provision"

#   # Use the kubeconfig generated by the control_nodes module
#   kubeconfig_path          = var.kubeconfig_path
#   environment              = local.environment
#   argocd_app_of_apps_repos = var.argocd_app_of_apps_repos

#   # Ensure the Kubernetes resources are only provisioned after the control nodes are ready
#   depends_on = [
#     module.control_plane_A,
#     module.control_plane_B,
#   ]
# }
